% Execution model
\begin{figure}[htb]
    \centering
    \includegraphics[width=\columnwidth]{ExecutionModel}
    \caption{Representation of the Task execution flow.}
    \label{fig:execution-model}
\end{figure}
\autoref{fig:execution-model} represents the flow of the execution of a Task
during the execution. As one can notice the flow is almost straightforward except
the initial part when the \emph{Task control} strategy tweak the execution to
fulfill some predefined requirements.

The System is able to operate in different scenarios, according to the logic
implemented in the \emph{Task planning}, the \emph{Task control} strategy may
change the flow of the execution. In \autoref{tab:execution-matrix} are presented
the different execution scenarios that the system is able to handle.
\begin{table}[htb]
	\caption{Task planning vs. Task Assignment.}
	\label{tab:execution-matrix}
	\centering
	\begin{tabular}{r|c|c}
		 & \textbf{Static} & \textbf{Dynamic}\\
		\hline
		\textbf{Static} & \ref{subs:static-static} & \ref{subs:static-dynamic}\\
		\hline
		\textbf{Dynamic} & \ref{subs:dynamic-static} & \ref{subs:dynamic-dynamic}
	\end{tabular}
\end{table}



\paragraph{Static execution}
\label{subs:static-static}
This scenario of execution represent the simplest use-case possible, where the
\emph{Task planning} is executed only once at creation time and the \utask{} are
planned and assigned only once. In this \code{mode} the \emph{Task control} have
only the role of controlling if the \emph{constraints} are verified. Here is a
list of the operation that the \emph{Task control} strategy must perform:
\begin{itemize}
	\item \textbf{Stop} a Task if constraints are met.
	\item \textbf{Invoke} the \emph{Aggregation function} at the end of the Task
	execution.
	\item \textbf{Notify} the \emph{Subscribers} about the Task execution.
\end{itemize}




\paragraph{Static \utask{} planning \& Dynamic assignment}
\label{subs:static-dynamic}
In this scenario the \utask{} are planned once at creation time, but the
assignment is performed dynamically. In this scenario the \emph{Task control}
strategy invokes the \emph{Performer assignment} strategy to assign
\emph{Performers} to \utask{}, ensuring that the constraints are verified. The
\emph{Task control} strategy can also decide to reassign \emph{Performer}s to
\utask{}, while ensuring constraints validity. In
this scenario the \emph{Task control} strategy:
\begin{itemize}
	\item \textbf{Stop} a Task if constraints are met.
	\item \textbf{Invoke} the \emph{Aggregation function} at the end of the Task
	execution.
	\item \textbf{Notify} the \emph{Subscribers} about the Task execution.
	\item \textbf{Invoke} the \emph{Performer assignment} strategy to bind \utask{}
	to \emph{Performer}s.
\end{itemize}





\paragraph{Dynamic \utask{} planning \& Static assignment}
\label{subs:dynamic-static}
In this scenario the \emph{Performer} assignment are performed at creation time
and the \utask{} planning is performed during the flow of the execution.
As one can notice this can lead to consistency problem due to the missing
\utask{} during the binding step. Since this scenario can lead to consistency
problems it must be used with care with respect to the others. To avoid problem
we suggest to use simple \emph{Performer} assignment such as the \code{fixed}
one, using this strategy we do not have to take care of the consistency.
Summing up, the Task Control Strategy:
\begin{itemize}
	\item \textbf{Stop} a Task if constraints are met.
	\item \textbf{Invoke} the \emph{Aggregation function} at the end of the Task
	execution.
	\item \textbf{Notify} the \emph{Subscribers} about the Task execution.
	\item \textbf{Invoke} the \emph{Task planning} strategy to \emph{re-plan}
	\utask{} or \textbf{Create} new \utask{}
\end{itemize}




\paragraph{Dynamic \utask{} planning \& Dynamic assignment}
\label{subs:dynamic-dynamic}
In this scenario all the assignments are performed dynamically. Here the \utask{}
can be associated either at creation time or during the flow of the execution.
The same stands for the \emph{Performer} assignment, this can be done at any time,
i.e. \emph{Performer}s can be assigned only upon the request of a Task execution. 
Summing up, the Task Control Strategy:
\begin{itemize}
	\item \textbf{Stop} a Task if constraints are met.
	\item \textbf{Invoke} the \emph{Aggregation function} at the end of the Task
	execution.
	\item \textbf{Notify} the \emph{Subscribers} about the Task execution.
	\item \textbf{Invoke} the \emph{Performer assignment} strategy to bind \utask{}
	to \emph{Performer}s.
	\item \textbf{Invoke} the \emph{Task planning} strategy to \emph{re-plan}
	\utask{} or \textbf{Create} new \utask{}
\end{itemize}


Now the built-in implementation of task creation, planning and execution are
described to better understand how the whole system works. The description is
focused on the built-in implementation, because it is the default behaviour of
the system. By pluggin-in custom strategies one can completely change how the
system behaves, thus this case will not be covered here. For examples on how the
pluggable strategies works see \ref{sec:model:strategies}.

\subsection{Task creation}
The task creation if performed by the \emph{Configurator} either by using its
web-interface or via API calls. The creation of a Work/Task can be done by
providing a JSON file, containing all the data definition as long as the data
instances, or "manually" following a step by step procedure within the
\emph{Configurator}. As shown in \autoref{fig:task-creation} the manual Task
creation involves the definition of a \textbf{Schema} for the data. The schema
is composed of \textbf{Field}s, for each filed the \emph{Requester} must specify
a type. The data instances can be added to the \emph{Schema} either during the
definition of the \emph{Fields} or at the end of the \emph{Schema} definition.

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.65\columnwidth]{task-creation}
    \caption{Work/Task creation flow.}
    \label{fig:task-creation}
\end{figure}



\subsection{Task planning}
\begin{figure}[htb]
    \centering
    \includegraphics[width=\columnwidth]{planning}
    \caption{Manual Task planning vs Automatic Task planning.}
    \label{fig:auto-manual-planning}
\end{figure}
The planning of a Task involves the creation of subtasks with associated data
that need to be executed. The assignment can be performed automatically or
manually. The automatic plan assignment uses a simple subdivision based on the
number of instances to assign to each subTask.

As depicted in \autoref{fig:task-planning} manual planning involves the
\emph{Requester} interaction in orer to create \textbf{subTasks}. After creating
the subTask the \emph{Requester} has to select the instances belonging to this
subTask. Eventually the \emph{Requester} is able to select and, if needed,
configure the type of the subTask, based on the task types of the parent Task.
\begin{figure}[htb]
    \centering
    \includegraphics[width=0.65\columnwidth]{task-planning}
    \caption{Task planning flow.}
    \label{fig:task-planning}
\end{figure}



\subsection{Task execution}




